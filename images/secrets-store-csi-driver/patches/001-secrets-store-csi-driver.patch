diff --git a/apis/v1/secretproviderclass_types.go b/apis/v1/secretproviderclass_types.go
index 43ef910c..c3249872 100644
--- a/apis/v1/secretproviderclass_types.go
+++ b/apis/v1/secretproviderclass_types.go
@@ -31,6 +31,9 @@ type SecretObjectData struct {
 	ObjectName string `json:"objectName,omitempty"`
 	// data field to populate
 	Key string `json:"key,omitempty"`
+	// decodeBase64 indicates whether the secret value should be base64 decoded before writing to file.
+	// Defaults to false if not specified.
+	DecodeBase64 bool `json:"decodeBase64,omitempty"`
 }
 
 // SecretObject defines the desired state of synced K8s secret objects
diff --git a/pkg/rotation/reconciler.go b/pkg/rotation/reconciler.go
index e82d12f7..88978428 100644
--- a/pkg/rotation/reconciler.go
+++ b/pkg/rotation/reconciler.go
@@ -340,6 +340,14 @@ func (r *Reconciler) reconcile(ctx context.Context, spcps *secretsstorev1.Secret
 		parameters[k] = v
 	}
 
+	if len(spc.Spec.SecretObjects) > 0 {
+		secretObjectsJSON, err := json.Marshal(spc.Spec.SecretObjects)
+		if err != nil {
+			return fmt.Errorf("failed to marshal secretObjects, err: %w", err)
+		}
+		parameters["secretObjects"] = string(secretObjectsJSON)
+	}
+
 	paramsJSON, err := json.Marshal(parameters)
 	if err != nil {
 		return fmt.Errorf("failed to marshal parameters, err: %w", err)
diff --git a/pkg/secrets-store/nodeserver.go b/pkg/secrets-store/nodeserver.go
index e2af8dcd..2641cd0f 100644
--- a/pkg/secrets-store/nodeserver.go
+++ b/pkg/secrets-store/nodeserver.go
@@ -205,6 +205,16 @@ func (ns *nodeServer) NodePublishVolume(ctx context.Context, req *csi.NodePublis
 		return nil, status.Error(codes.InvalidArgument, "Readonly is not true in request")
 	}
 
+	// add secretObjects information to parameters for provider
+	if len(spc.Spec.SecretObjects) > 0 {
+		secretObjectsJSON, err := json.Marshal(spc.Spec.SecretObjects)
+		if err != nil {
+			klog.ErrorS(err, "failed to marshal secretObjects", "pod", klog.ObjectRef{Namespace: podNamespace, Name: podName})
+			return nil, err
+		}
+		parameters["secretObjects"] = string(secretObjectsJSON)
+	}
+
 	parametersStr, err := json.Marshal(parameters)
 	if err != nil {
 		klog.ErrorS(err, "failed to marshal parameters", "pod", klog.ObjectRef{Namespace: podNamespace, Name: podName})
diff --git a/pkg/secrets-store/provider_client.go b/pkg/secrets-store/provider_client.go
index 2672f53b..a787b98b 100644
--- a/pkg/secrets-store/provider_client.go
+++ b/pkg/secrets-store/provider_client.go
@@ -18,6 +18,7 @@ package secretsstore
 
 import (
 	"context"
+	"encoding/json"
 	"errors"
 	"fmt"
 	"net"
@@ -272,7 +273,14 @@ func MountContent(ctx context.Context, client v1alpha1.CSIDriverProviderClient,
 		return objectVersions, "", nil
 	}
 
-	if err := fileutil.WritePayloads(targetPath, resp.GetFiles()); err != nil {
+	// extract secretObjects from attributes for base64 decoding
+	var secretObjectsJSON string
+	var attrib map[string]string
+	if err := json.Unmarshal([]byte(attributes), &attrib); err == nil {
+		secretObjectsJSON = attrib["secretObjects"]
+	}
+
+	if err := fileutil.WritePayloads(targetPath, resp.GetFiles(), secretObjectsJSON); err != nil {
 		return nil, internalerrors.FileWriteError, err
 	}
 	klog.V(5).Info("mount response files written.")
diff --git a/pkg/util/fileutil/writer.go b/pkg/util/fileutil/writer.go
index 69c540cf..517e93dd 100644
--- a/pkg/util/fileutil/writer.go
+++ b/pkg/util/fileutil/writer.go
@@ -17,11 +17,14 @@ limitations under the License.
 package fileutil
 
 import (
+	"encoding/base64"
+	"encoding/json"
 	"fmt"
 	"os"
 	"path/filepath"
 	"strings"
 
+	secretsstorev1 "sigs.k8s.io/secrets-store-csi-driver/apis/v1"
 	"sigs.k8s.io/secrets-store-csi-driver/provider/v1alpha1"
 )
 
@@ -42,7 +45,7 @@ func Validate(payloads []*v1alpha1.File) error {
 // WritePayloads writes the files to target directory. This helper builds the
 // atomic writer and converts the v1alpha1.File proto to the FileProjection type
 // used by the atomic writer.
-func WritePayloads(path string, payloads []*v1alpha1.File) error {
+func WritePayloads(path string, payloads []*v1alpha1.File, secretObjectsJSON string) error {
 	if err := Validate(payloads); err != nil {
 		return err
 	}
@@ -58,11 +61,37 @@ func WritePayloads(path string, payloads []*v1alpha1.File) error {
 		return err
 	}
 
+	// parse secretObjects to get decodeBase64 information
+	decodeBase64Map := make(map[string]bool)
+	if secretObjectsJSON != "" {
+		var secretObjects []*secretsstorev1.SecretObject
+		if err := json.Unmarshal([]byte(secretObjectsJSON), &secretObjects); err == nil {
+			for _, secretObj := range secretObjects {
+				for _, data := range secretObj.Data {
+					if data.DecodeBase64 {
+						decodeBase64Map[data.ObjectName] = true
+					}
+				}
+			}
+		}
+	}
+
 	// convert v1alpha1.File to FileProjection
 	files := make(map[string]FileProjection, len(payloads))
 	for _, payload := range payloads {
+		contents := payload.GetContents()
+
+		// check if this file should be base64 decoded
+		if decodeBase64Map[payload.GetPath()] {
+			decoded, err := base64.StdEncoding.DecodeString(string(contents))
+			if err != nil {
+				return fmt.Errorf("failed to decode base64 for file %s: %w", payload.GetPath(), err)
+			}
+			contents = decoded
+		}
+
 		files[payload.GetPath()] = FileProjection{
-			Data: payload.GetContents(),
+			Data: contents,
 			Mode: payload.GetMode(),
 		}
 	}
